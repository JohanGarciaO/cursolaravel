******************************************************************************
LARAVEL

// Diretório que armazena todas as entidades do Laravel
use Illuminate\Http\Request

Laravel: nada mais é do que uma abstração de códigos em comum (Utiliza o padrão MVC)

O Laravel tem diversos serviços já prontos para serem utilizados, estes serviços ficam na pasta /vendor/laravel/framework/src



******************************************************************************
ROTAS

// Verbo GET permite obter o request de uma requisição
Route::get('/', function () {
    return view('welcome');
});

// Verbo ANY não muito comum mas permite qualquer tipo de requisição http nesta rota
Route::any('/any', function () {
    return "Permite todo tipo de acesso HTTP (get, post, put, delete...)";
});

// Verbo MATCH é o inverso do ANY, o match permite apenas requisições dos tipos predefinidas no primeiro parâmetro
Route::match(['put', 'post'], '/match', function () {
    return "Permite apenas acessos definidos";
});

// Passagem de parâmetro nas rotas (sem interrogação aquele parâmetro fica obrigatório)
Route::get('produto/{id}/{cat?}', function ($id, $cat = 'Categoria não definida') {
    return "O id do produto é: $id<br>A categoria é: $cat";
});

// Redirecionamento de Rotas
// Route::get('sobre', function () {
//     return redirect('/empresa');
// });

// Redirecionamento de Rotas usando o verbo REDIRECT
Route::redirect('/sobre', '/empresa');

// Renderiza uma view sem precisar colocar dentro de uma função de callback de uma rota do tipo GET
Route::view('/empresa', '/site/empresa');

// ROTAS NOMEADAS -> é feito o redirecionamento através do NOME da rota e não da rota em si, desta maneira, se a rota for modificada e o nome não, o redirecionamento continuará sendo feito para o novo endereço de rota
Route::get('/timesnownews', function () {
    return view('news');
})->name('noticias');

Route::get('/novidades', function () {
    return redirect()->route('noticias');
});

******************************************************************************
GRUPO DE ROTAS

// Agrupar todo mundo pelo prefixo da rota
Route::prefix('admin')->group(function () {
    Route::get('/dashboard', function () {
        return "dashboard";
    });

    Route::get('/users', function () {
        return "users";
    });

    Route::get('/clientes', function () {
        return "clientes";
    });
});

// Agrupar todo mundo pelo prefixo do nome
Route::name('admin.')->group(function () {
    Route::get('admin/dashboard', function () {
        return "dashboard";
    })->name('dashboard');

    Route::get('admin/users', function () {
        return "users";
    })->name('users');

    Route::get('admin/clientes', function () {
        return "clientes";
    })->name('clientes');
});

// Agrupar todo mundo pelo tanto prefixo da rota quanto do nome, ou qualquer outro tipo de agrupamento (lembrando que a chave para o prefixo do nome utilizando o Route::name é o name mas utilizando o group é o "as")
Route::group([
    'prefix' => 'admin',
    'as' => 'admin.'
], function () {
    Route::get('dashboard', function () {
        return "dashboard";
    })->name('dashboard');

    Route::get('users', function () {
        return "users";
    })->name('users');

    Route::get('clientes', function () {
        return "clientes";
    })->name('clientes');
});

******************************************************************************
CONTROLLERS

Para criar um Controller (nome em Pascal Case): php artisan make:controller ProdutoController

Dentro do controller você escreve suas functions como por exemplo:
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class ProdutoController extends Controller
{
    public function index()
    {
        return "index";
    }
}


// Primeiro importa o Controller com o namespace
use App\Http\Controllers\ProdutoController;

// Depois cria uma rota onde o primeiro parâmetro é a rota e o segundo é o controller que vai responder por essa rota
Route::get('/', [ProdutoController::class, 'index']);

OBS: Os controllers utilizam o serviço Requests do Laravel, que:
Request: é um recurso para obter uma instância via injeção de dependência da solicitação http

// Passar parâmetros para responder um método de vizualização de produto
Route::get('/produto/{id?}', [ProdutoController::class, 'show'])->name('produto.show');

Obs: lembre se criar o método no controller, se quiser deixar opcional colocar o interrogação pós parâmetro, e definifir o valor nos parâmetros de criação do método no controller
public function show($id = 0)
    {
        return "Show: " . $id;
    }

Obs: lembrando que é altamente recomendado definir nomes para as rotas


******************************************************************************
RESOURCE

Alguns recursos são tão genéricos que o framework (laravel, que busca ganho de tempo e agilidade) já considera disponibilizar com apenas uma linha de código,
Isso é o exemplo dos RESOURCES

Vamos apagar o ProdutoController antigo e criar novamente, agora com: php artisan make:controller ProdutoController --resource

Desta maneira o controller já vai vir com diversos métodos já pré configurados. São eles:

- index: para listar
- create: exibir um formulário
- store: salvar os registros que vamos receber via injeção de dependências através do Request
- show: exibir um recurso específico pelo id
- edit: exibir um formulário para edição de algum recurso
- update: para atualizar algum recurso
- destroy: para a gente remover algum recurso da base de dados

Logo, o Resource é uma mão na roda para manipulação de banco de dados

// Definindo a rota de um Resouce no web.php
Route::resource('produtos', ProdutoController::class);

Só em ir no navegador de colocar na rota Produtos já será retornado o método index sem precisar especificar

******************************************************************************
COMANDOS ROUTE

php artisan route:list -> PARA LISTAR AS ROTAS DE SUA APLICAÇÃO
route:cache -> Vai criar um arquivo de cache de rota para deixar a resposta de requisição mais rápida (não recomendado trabalhando em produção)
route:clear -> Remove o arquivo de Cache de Rotas

******************************************************************************
CONEXÃO COM O BANCO DE DADOS

No .env tem uma sessão de variáveis com um prefixo DB_ (elas representam os dados de conexão do banco de dados)

Também existe o arquivo config\database.php que possui um setup com vários valores defauls prontos para serem usados caso não sejem setados na .env

Obs: agora eu criei o DB cursolaravel através do HeideSQL e alterei o .env

******************************************************************************
MIGRATIONS -> é um recurso utilizado para manipulação de dados no DB

Na pasta database/migrations podemos observar que já vieram alguns arquivos prontos

2014_10_12_000000_create_users_table.php: cria uma tabela já de usuários
2014_10_12_100000_create_password_resets_table.php: reseta senha caso precise
2019_08_19_000000_create_failed_jobs_table.php: usado quando trabalhando com Fillas
2019_12_14_000001_create_personal_access_tokens_table.php: para trabalharmos com token

Obs.: O Laravel já trouxe esses quatro migrations prontos, mas é importante entender que esses migrations PRECISAM ser CRIADOS.

Portanto, observemos sua estrutura:

Todos possuem um método UP e um método DOWN,

UP: acionado quando o migration é executado (meio que cria toda a estrutura)

DOWN: acionado quando revertemos um migration


Podemos observar no migration que veio pronto de criação de tabela de usuários, que está sendo usádo o Método CREATE do Serviço SCHEMA
Ele está criando uma tabela chamada users e definindo as colunas desta tabela

public function up(){
    Schema::create('users', function (Blueprint $table) {
        $table->id();
        $table->string('name');
        $table->string('email')->unique();
        $table->timestamp('email_verified_at')->nullable();
        $table->string('password');
        $table->rememberToken();
        $table->timestamps();
    });
}


Comandos migrations:

php artisan migrate -> executa todos os migrations (cria todas as tabelas)

migrate:fresh -> deleta todas as tabelas e depois reexecuta todas as migrações
migrate:install 
migrate:refresh -> reseta e já reexecuta, ele meio que dar um reset e depois executa tudo
migrate:reset -> reverte todas as migrações (é tipo um rollback, mas de todas as migrações)
migrate:rollback -> desfaz o último migrate (a última migração)
migrate:status -> exibe o status de nossos migrations (o nome e se foi executado ou não)

E para criar nossas tabelas? Precisamos criar um migration (para o nome do migration use a convenção de Snake Case)
php artisan make:migration create_produtos_table

Ele vai criar o Migration com a estrutura prontinha, depois é só completar os campos
Obs.: se eu tivesse usado um nome aleatório (sem o prefixo do nome create e o sufixo table) o migration não ia identificar o que você precisa e entregaria os métodos up e down vazios

Mas se quiser criar um migration sem usar o prefixo e sufixo do nome e ainda assim ele vir com algumas coisas prontas como o outro, podemos criar o migrate da seguinte maneira:
php artisan make:migration produtos --create=produtos

Além de criar, também podemos editar estas tabelas, renomear , excluir...

Vamos criar um migration para alterar o nome da tabela produtudos:
    - php artisan make:migration alterar_nome_tabela_produtos
    - No método up() do migrate vamos colocar Schema::rename('produtos', 'produto'); e ao executar esse migrate o nome da tabela será renomeado

Os migrates são feitos para serem executados de forma sequencial, então uns podem depender de outros
Ex: não daria pra mudar o nome da tabela produtos se a tabela já não existisse previamente

Também podemos criar um migrate para apagar uma tabela, dentro do up vamos usar Schema::dropIfExists('produto');

Também conseguimos modificar as colunas via migrations, mas precisamos instalar uma dependência chamada doctrine/dbal (caso a versão do Laravel seja inferior a 11)

Copnseguimos criar tabelas e definir colunas, mas para modificar as colunas precisamos dessa lib

********* MODIFICANDO COLUNAS

Vou criar duas colunas no migration da tabela produtos
    $table->string('nomee');
    $table->string('nomecompleto');

Agora vamos modificar a coluna 'nomee' para 'nome' e apagar a outra

    Dentro do migration, vamos no Up() e definimos em Schema::table a tabela que vamos estar trabalhando e uma função de callback com o Blueprint passando para o objeto $table
    Obs: meio que o Blueprint gera uma instância da tabela e coloca no objeto table, modificamos esse objeto e depois o Blueprint efetiva as mudanças

    Blueprint: recurso de geração de código do Laravel

    Agora camos renomear a coluna e apagar a outra, o código fica:

    public function up()
    {
        Schema::table('produtos', function (Blueprint $table) {
            $table->renameColumn('nomee', 'nome');
            $table->dropColumn('nomecompleto');
        });
    }

******************************************************************************
MODELS

É a representação de uma entidade

Então vamos criar uma model com: php artisan make:model produto

Depois podemos criar um registro aleatório no banco na tabela produtos e vizualizar no index de nosso controle,
para isto, devemos ir na index de nosso ProdutoController e definir:

    $produtos = \App\Models\Produto::all();
    return dd($produtos);

Primeiro instanciamos o objeto produto usando o método all() que pegou todos os dados da tabela produto
depois retornamos a função dd($produto) passando o objeto, esta função debuga os dados de nosso objeto na tela

Este é um método do Eloquent (que é um ORM do Laravel)

ORM -> Object Relational Model, serve para mapear de modo automático uma tabela de um banco de dados para dentro de uma classe

OU SEJA, O MODEL SERVE PARA REPRESENTAR UMA TABELA (ENTIDADE)

Obs.: Observe que o Laravel é tão inteligente que nossa tabela se chama "produtos", criamos um model chamado "Produto" e ainda assim ele relacionou com a tabela.
MAS, caso não tivesse conseguido relacionar, deveriamos especificar o nome da tabela com o:

    - protected $table = 'produtos';

Alí na index do controller onde definimos o objeto $produtos passando o Path do Model, podemos resumir e colocar só Produto
Para isso basta colocar no início do arquivo um namespace com: use \App\Models\Produto;

******************************************************************************
CRIANDO TABELAS USERS, CATEGORIAS E PRODUTOS

1. Vamos deletar o migrate update_produtos
2. Vamos de fato definir a estrutura de nossa tabela

    public function up()
    {
        Schema::create('produtos', function (Blueprint $table) {
            $table->id(); // Cria um campo id (autoincrement, inteiro e primary key)
            $table->string('nome'); // campo nome do tipo string
            $table->text('descricao'); // campo descricao do tipo text
            $table->double('preco', 10, 2); // campo preco do tipo double com 2 casas decimais
            $table->string('slug'); // campo slub do tipo string
            $table->string('imagem')->nullable(); // campo imagem para armazenar o path de uma imagem (pode ser nulo)
            $table->unsignedBigInteger('id_user'); // campo que vai armazenar o valor da FK
            $table->foreign('id_user')->references('id')->on('users')->onDelete('cascade')->onUpdate('cascade'); // Cria o relacionamento da FK dizendo onde tá referenciando e qual tipo de relacionamento, neste caso 'cascade'
            $table->timestamps(); // cria dois campos: created_at e updated_at
        });
    }

    Como o Relacionamento é cascade se um usuário for deletado todos os produtos daquele usuário também será deletado
    
    Quabdo usamos estes métodos nas colunas/relacionamentos estamos encadeando uma propriedade...
    EX: 
        ->unique(): define aquela coluna com de valor único
        ->nullable(): permite valores nulos
3. Vamos criar os Models e Migrations necessários

    - Podemos criar tanto o model quanto o migration com um único comando:
        php artisan make:model Categoria --migration

    - Ou até mesmo ainda um controller (e do tipo resource se quiser):
        php artisan make:model Categoria --migration --controller --resource

    - Ou, mais resumidamente ainda:
        php artisan make:model Categoria -m -cr

    - Ou:
        php artisan make:model Categoria -mcr

4. Agora vou implementar um nome e uma descrição no migrate da categoria
5. Precisamos nos atentar ao fato de que os migrations foram feitos para serem executados de modo sequencial
    e por isso o nome deles possui uma data e uma numeração antes do nome de fato do migration.

    Portanto, sabendo que estamos usando agora chaves estrangeiras, da forma como geramos nosso código estamos
    criando um relacionamento com a tabela Categoria antes mesmo de criar a tabela. Então vamos resolver isso
    simplesmente alterando a ordem dos migrations mudando o nome.

******************************************************************************
SEEDER

Recurso que utilizamos para ganhar tempo na inserção de registros no banco de dados

Vamos criar um seeder para adicionar um usuário em nossa tabela

1. php artisan make:seeder UsersSeeder
    isso gerará o arquivo de seeder, que é bem simples e tem apenas um método (o run(), que é a ação de quando executado)
2. Precisamos fazer esta seeder conversar com o Model User, repare que:
    - Possui um array de atributos chamado fillable (define quais campos serão permitidos inserção em massa)
    Precisamos modificar pra deixar de acordo com as colunas que queremos modificar
3. Vamos IMPORTAR o Model no Seeder:
    use App\Models\User;

    assim poderemos usar o método User::create() para criar nossos usuários
4. Agora vamos implementar a criação de um usuário:

    public function run()
    {
        User::create([
            'firstName' => 'Johan',
            'lastName' => 'Garcia',
            'email' => 'contato@johan.com',
            'password' => bcrypt('12345678'),
        ]);
    }

5. Agora no DatabaseSeeder iremos utilizar o $this para passar um array com classes de Seeders que serão executadas
    
    public function run()
    {
        // \App\Models\User::factory(10)->create();
        $this->call([
            UsersSeeder::class,
        ]);
    }

******************************************************************************
FACTORY
-> Para que não precisemos inserir registro por registro e inserir alguns registros específicos em massa para testar

1. Vamos usar o Factory para gerar 5 categorias de forma automática

    - Primeiro vamos criar o Factory com: php artisan make:factory CategoriaFactory

2. Agora dentro da estrutura definition() vamos gerar uma estrutura modelo para ser executada p/ gerar o cadastro

    - A tabela cadastro possui o campo nome e descricao, então vamos colocá-los no Factory e usar o $this->fake p/ gerar registros falsos

    public function definition()
    {  return [
            'nome' => $this->faker->unique()->word, // gera uma palavra fake única      
            'descricao' => $this->faker->text,
        ];
    }

3. Agora precisamos criar um Seeder para executar este Factory:
    - php artisan make:seeder CategoriasSeeder

    BOAS PRÁTICAS:
        - Factory -> singular
        - Seeder -> plural

    Vamos importar o Model no Seeder com: user App\modules\Categoria;

    E em seguida, geramos os 5 registros com o factory encadeando no create:

    public function run()
    {
        Categoria::factory(5)->create();
    }

4. Agora precisamos definir a nossa CategoriaFactory na call do DatabaseSeeder
    Detalhe, se formos executar apenas esta Seeder, não precisa do array na call e pode passar direto na call()
    Ficando: $this->call(CategoriasSeeder::class);

5. Agora basta executar a seed do projeto:
    php artisan db:seed

******************************************************************************
MFSCR

Podemos criar todos esse recursos com um só comando, com:

    php artisan make:model Teste --migration --factory --seed --controller --
    
Ou,

    php artisan make:model Teste -mfscr

******************************************************************************
FACTORY PRODUTOS e STRSLUG

O Laravel dispõem para a gente uma série de classes para serem utilizadas e uma delas é o Str (que serve para gerar uma Url amigável)

Até então só vimos o método create do Eloquent, mas tem outros, como é o caso do pluck
Pluck: extrai uma informação de uma tabela (no nosso caso queremos o id das tabelas Users e Categorias para fazer o relacionamento)

O definition() de nossa factory ficou da seguinte maneira:

    public function definition()
    {   
        $name = $this->faker->unique()->sentence(); // Define o valor de nome antes para colocar em uma variável
        return [
            'nome' => $name, // define nome
            'descricao' => $this->faker->paragraph(), // define a descricao como um parágrafo fake
            'preco' => $this->faker->randomNumber(2), // gera um número aleatório para colocar em preco
            'slug' => Str::slug($name), // gera uma url com a classe Str
            'imagem' => $this->faker>imageUrl(400, 400), // gera a url de uma imagem de dimensão 400x400
            'id_user' => User::pluck('id')->random(), // Extrai randomicamente um dos Ids da tabela users
            'id_categoria' => Categoria::pluck('id')->random(), // Extrai randomicamente um dos Ids da tabela categorias
        ];
    }

Agora iremos definir a nossa Seed:

    public function run()
    {
        Produto::factory(20)->create();
    }

Por últimos chamamos a seed no DatabaseSeeder

******************************************************************************
RELACIONAMENTOS

1. Vamos começar criando dois migrations
    - php artisan make:migration contatos --create=contatos
    - php artisan make:migration regras --create=regras

    Antes nós tinhamos um relacionamento de 1 para muitos entre produtos e usuários (1 user pode ter muitos produtos)
    
2. Agora vamos criar um relacionamento de 1:1 entre usuário e contato para que cada usuário tenha apenas 1:

    public function up()
    {
        Schema::create('contatos', function (Blueprint $table) {
            $table->id();
            $table->string('cpf');
            $table->string('cep');
            $table->string('numero');
            $table->string('whatsapp');
            
            $table->unsignedBigInteger('id_user');
            $table->foreign('id_user')->references('id')->on('users')->onDelete('cascade')->onUpdate('cascade');

            $table->timestamps();
        });
    }

3. Vamos criar um relacionamento de n:n entre a tabela regras e usuários:

    public function up()
    {
        Schema::create('regras', function (Blueprint $table) {
            $table->id();
            $table->string('nome');
            $table->timestamps();
        });

        Schema::create('regra_user', function (Blueprint $table) {
            $table->id();

            $table->unsignedBigInteger('id_user');
            $table->foreign('id_user')->references('id')->on('users');

            $table->unsignedBigInteger('id_regra');
            $table->foreign('id_regra')->references('id')->on('regras');

            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('regras');
        Schema::dropIfExists('regra_user');
    }

    Repare que para criar um relacionamento de n:n devemos criar outra tabela entre as tabelas relacionadas.

4. Agora basta dar um: php artisan migrate

******************************************************************************
VIEWS

Aa Views é a camada do MVC responsável pela vizualização

Ficam dentro da pasta Resource e sua extensão é .blade.php

Blade: sistema de templates do Laravel

É responsabilidade da View renderizar o HTML

QUAL É O FLUXO???

1. Temos uma rota (controller) do tipo Resource em Produtos

    - Então quando acessamos produtos, o Controller ProdutoController responde por essas rotas
    - Route::resource('produtos', ProdutoController::class);

2. Agora vamos mudar esta rota para que ao invés de mostrar os produtos ele retorne uma view, fazemos isso com:

    return view('news');

    Isso mesmo, não precisa botar a extenção, o Laravel já interpreta tudo
    
    Desse modo vamos conseguir renderizar um HTML em nossa aplicação.

    Obs.: Caso dentro da pasta View a gente tivesse uma outra pasta chamada Site bastava passa o caminho com / ou . que seria renderizado.
    return view('site.empresa'); ou return view('site/empresa');

3. E como fazemos para passar um dado para a View?

    Basta passar em um array na rota:

    public function index()
    {
        $nome = 'Johan';
        $idade = 22;

        return view('site.empresa', ['nome' => $nome, 'idade' => $idade]);
    }

4. E para usar esse valor na View???

    Só usar {{}} chaves duplas.

    Ex: <span>Meu nome é {{ $nome }} e minha idade é {{$idade}}.</span>

5. E se nossa variável tivesse conteúdo HTML, como exibiríamos na View?

    Já adianto que com chaves duplas iria mostrar na tela o html literal

    Para renderizar o HTML ao invés de chaves duplas vamos usar chaves e dupla exclamação:

    Passando na rota:           $html = "<h1> Olá, eu sou H1</h1>";
    Renderizando na view:       {!!$html!!}

6. Também tem outra forma de passar as informações para as views sem precisar ser através de Array, para isso usamos o compact():

    return view('site.empresa', compact('nome', 'idade', 'html'));

    basta passar o nome da variável que a função já crias as variáveis na view manualmente

    Atenção, não pode passar atributo no compact de variável que já não exista previamente

******************************************************************************
Section, Yield e extends

Vamos agora trabalhar com nosso sistema de templates

1. Vamos deletar alguns arquivos: welcome.blade, news.blade
2. Renomear o empresa.blade para layout.blade.php
3. Criar em site mais um arquivo chamado home.blade.php

Dentro do layout vamos gerar uma estrutura padrão de HTML e no body vamos usar a nossa primeira diretiva (@yield) para incorporar o nosso conteúdo

    <body>
        @yield('conteudo')
    </body>

Agora para herdar a estrutura de um .blade podemos usar a diretiva @extends, então no home.blade podemos herdar o layout
    
    Logo, dentro do arquivo colocamos apenas: @extends('site.layout') e já vai herdar a estrutura

    Mas ainda no home delimitamos através da @section() e @endsection onde será encontrado o nosso conteúdo

    Ou seja, se no layout foi definido um @yield('conteudo'), lá no home dentro do @session('conteudo') passamos o mesmo nome usado no @yield. E aí todo conteúdo delimitado no @session irá ficar onde foi colocado o @yield no layout.

Desse modo, a home.blade ficou:

    @extends('site.layout')

    @section('conteudo')
    <h1>Essa é nossa Home.</h1>
    @endsection

    Isso herda a estrutura html que foi colocada no layout e coloca o que está delimitado na @section dentro de onde foi apontado no @yield do layout

Podemos por exemplo criar uma sessão para o title e um yield no layout e aí o título ficará dinâmico, isso pode ser feito com o @sectione @endsection
normalmente ou em apenas uma linha passando dois parâmetros para o section:     

    @section('title','home')

    E no lugar do título do layout um @yield('title'), óbvio

****************************************************************************** CHEGANDO AQUI TEMOS UMA VISÃO GERAL DA MECÂNICA DO LARAVEL
Laravel Snippers

Vamos instalar algumas extensões:

    1. Laravel Blade Snippets (deixa os templates mais amigáveis e nos ajuda com alguns triggers: autocompletes)
        - Vai ter uma colocaração diferentes as diretivas

    2. Laravel Snippets (Para as Rotas)
        - Só em digitar um Route-ControllerAction já vai autocomlpetar pra gente com:   Route::get('users/{id}', [UserController::class, 'index'])->name('user.index');
        Já cria a rota, só substituir o valores

******************************************************************************
Comentários e Operador Ternário

Comentários: no blade usamos {{--comentário--}} duplo traço dentro de dupla chaves
    - Estes comentários não são renderizados em nosso código fonte

Operador Ternário: 

    Como exemplo vamos verificar a existência de uma variável e exibir um conteúdo:

        {{ isset($nome) ? $nome : 'Sem nome'}}

    Também podemos definir um valor padrão para uma variável, será mostrado caso a variável não exista. Fazemos isso com: 

        {{$teste ?? 'Padrão'}}

******************************************************************************
CUSTOMIZANDO VIEWS DE ERRO

Criamos dentro da Pasta Views, umas pasta chamada errors, e dentro dela um arquivo com o código do erro. Ex: 404.blade.php

Temos o erro 500 que é de servidor, então se gerarmos propositalmente um erro de sintaxe em uma rota, criar o arquivo com o código do erro e na nossa .env colocar um false p/ APP_DEBUG=false conseguiremos renderizar essa view de erro

******************************************************************************
ESTRUTURAS DE CONTROLE

Basta usar a diretiva @if. Exemplo:

    @if($nome == 'Johan')
        true
    @else
        false
    @endif

    imprime true se for verdadeira

E temos o contrário do If, que é o unless (é tipo a condição negada):

    @unless($nome == 'Johan')
        true
    @else
        false
    @endunless

    imprime true se for falsa

Também temos o bom e velho Switch:

    @switch($idade)
        @case(22)
            Idade está ok
            @break
        @case(21)
            Idade está errada
            @break
        @default            
    @endswitch

Obs.: lembrando que com os snippets só em escrever switch ele já autocompleta, assim como para as outras estruturas

Temos o isset (para verificar se existe):

    @isset($nome)
        Existe
    @endisset

Temos o empty (para verificar se está vazia):

    @empty($nome)
        Vazia
    @endempty

Temos uma diretiva para verificar se existe um usuário autenticado @auth:

    @auth
        Está autenticado
    @endauth

    Imprime se tiver um usuário autenticado

Mas temos o inverso do @auth para retornar o valor caso não haja nenhum usuário autenticado:

    @guest
        Ninguém está autenticado
    @endguest

    Imprime se não tiver nenhum usuário autenticado

******************************************************************************
ESTRUTURAS DE REPETIÇÃO

Temos o FOR:

    @for ($i = 0; $i < 10; $i++)
        Valor atual é {{$i}} <br>
    @endfor

Também temos o While (mas aí precisamos criar blocos php para definir e incrementar a variável, pode ser usando a própria diretiva pra criar os blocos):

    @php
        $i = 0;
    @endphp

    @while ($i <= 10)
        valor atual com o while é {{$i}} <br>
        @php $i++; @endphp
    @endwhile

Podemos usar o ForEach:

    Antes vou passar um array $frutas = ['banana', 'laranja', 'maça']; na nossa rota para dentro da View

    @foreach ($frutas as $fruit)
        {{$fruit}}
    @endforeach

Caso queiramos usar o foreach de um modo que tenha um valor padrão para caso o array esteja vazio, podemos usar a diretiva @forelse e no final a @empty sem precisar fechá-la:

    @forelse ($frutas as $fruit)
        {{$fruit}}
        @empty
            O array está vazio
    @endforelse

******************************************************************************
INCLUDE

1. Vamos criar uma pasta em views chamada includes, e dentro dela um arquivo chamado mensagem.blade.php com o conteúdo:

    <h1>Esta é uma mensagem</h1>
    <p>Texto qualquer</p>

2. Como incluir isso em nossa view home?

    Basta usar o @include('includes.mensagem',['título' => 'Mensagem de sucesso!'])

    Primeiro parâmetro é o local da view a incluir e o seguindo é um array com valores para serem exibidos dinamicamente

    No arquivo incluido pra usar essa variável é só usar o {{}}

COMPONENT

1. Criaremos uma pasta chamada components em views, dentro um sidebar.blade.php, dentro dele:

    <div style="background-color: black; color: #fff">
        <h1>Sidebar</h1>
        <p></p>
    </div>

2. Para usar esse Component no home basta usar a diretiva @component:

    @component('components.sidebar')
        
    @endcomponent

3. Para cria um conteúdo dinâmico p/ esse component usamos a diretiva @slot passando um nome:

    @component('components.sidebar')
        @slot('paragrafo')
            Texto qualquer vindo do slot
        @endslot
    @endcomponent

4. E para utilizar esse conteúdo dinâmico no Component basta usar a tag de impressão e o nome do slot {{$paragrafo}}

******************************************************************************
STRACKS e PUSH

Os Stracks são usados para controlar em quais views serão renderizados determinados scripts, estílos ou arquivos externos

Ex: se eu fosse importar alguns scripts ou instalar algum framework css como o bootstrap ou materialize, ao instalar via CDN (colocando o link no html) do layout
    este script/framework irá afetar todas as views que herdam este layout.

Então para controlar isso e definir quem de fato fará uso daquelas importações, usamos o stack. Ex:

    @stack('style')


    Coloca isso no layout.blade

Aí na view que queremos utilizar, usamos o @push para carregar determinada importação para o @Strack do template:

    @push('style')
        <!-- Compiled and minified CSS -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    @endpush

    Isso vai carregar o @strack 'style' com o css do materialize, e como tem um strack chamado style no template layout.blade. Na renderização o que tiver sido carregado no @push aparecerar em seu devido @Strack

******************************************************************************
VIEWCACHE e VIEWCLEAR

1. Coloca o APP DEBUG true novamente no .env
2. Vamos deletar a pasta Components e a pasta Includes
3. Vamos limpar nossa home.blade apagando os push, component e include. E apagar os Stack de nosso layout
4. Agora abrindo terminal veremos que temos dois comandos para trabalhar com as views, o view cache e o view clear

O Laravel compila nossas views por demanda, então ele escolhe o melhor momento para compilar as views. Depois ele se encarrega de verificar se alguma view foi modificada para recompilá-la

    - php artisan view:cache 
        Força o Laravel a pré-compilar as views para ter um melhor desempenho (mas não é muito recomendado)

    - php artisan view:clear
        Às vezes fazemos algumas alterações nas views e parece que nada surtiu efeito na página, pode ser porque o sistema esteja pegando as views do cache, então podemos usar o clear para limpar o cache de nossas views

******************************************************************************
IMPLEMENTANDO O MATERIALIZE

Vamos implementar um Framework CSS via CDN.

1. Basta colar os links direto no layout, ou usar os stacks e push, como já foi feito anteriormente.

2. Agora vamos criar um navbar (no próprio site do Materialize temos os modelos de componentes já prontos). Vamos mudar só algumas coisas, ficando:

    <nav class="red">
        <div class="nav-wrapper container">
            <a href="#" class="brand-logo center">CursoLaravel</a>
            <ul id="nav-mobile" class="left">
                <li><a href="">Home</a></li>
                <li><a href="">Carrinho</a></li>
            </ul>
        </div>
    </nav>

    Acrescentamos uma cor ao navbar com a classe red
    add class container na div p/ centralizar tudo
    center na logo
    left na lista e retiramos o 'hide-on-med-and-down' p/ não ocultar a lista em dispositivos menores

3. Agora vamos ao conteúdo no nosso home.blade:

    <div class="row container">
        <div class="col s12 m3">            
        </div>
        <div class="col s12 m3">            
        </div>
        <div class="col s12 m3">            
        </div>
        <div class="col s12 m3">            
        </div>
    </div>

    Vamos criar uma row e dentro quatro colunas que em dispositovos pequenos ocupam o tamanho máximo 12 e em médios ocupa o tamanho de 3, ficando as 4 em uma linha. Essas classes já são tudo do materialize

    O 'container' na row faz com que tudo fique centralizado

4. Como estamos trabalhando com listagem de produtos, vamos usar outro componente do materialize chamado Cards

    Então, dentro dos col colocamos o restante do conteúdo dos cards

    Repare que só em fazer isso não vai funcionar completamente, se o card tiver imagem não vai aparecer porque de fato não baixamos a imagem para nossa raiz, agora os ícones vão dar errado pq não instalamos o pacote 
    de ícones do materialize

    Então para isso, vamos no site do materialize->componentes->icons e lá vai ter um link para importarmos via CDN

    Mas não somos obrigados a utilizar o ícone que já veio no card, lá no site do materialize tem uma opção chamada "search Google icons" e lá terá muitos ícones para a gente escolher
    Então vamos personalizar, vou pesquisar por view nos ícones do google e escolher um, tem um bom chamado visibility, então basta colar esse nome dentro de um span com a classe material-icons

******************************************************************************
AGORA VAMOS DE FATO FAZER A LISTAGEM DOS PRODUTOS

    1. Primeiro vamos recaptular: temos uma rota resource chamada Produtos, nela, uma de suas rotas é a index, vamos apagar o conteúdo e deixar somente a listagem dos produtos para dentro de uma variável com o 
        método ::all do nosso ORM (o Eloquent)

        $produtos = Produto::all();
        
        Onde Produto é nossa Model

    2. Para passar o objeto produtos para a nossa view é muito simples, basta usar o Compact:

        return view('site.home', compact('produtos'));

Antes de listarmos os produtos lembre de ter executado suas seeders com php artisan db:seed para garantir que que os dados estejam registrados no bando de dados

    3. Vamos criar um loop com a diretriz foreach no home.blade e lá colocamos o card consumindo o produto

        @foreach ($produtos as $product)
            <div class="col s12 m3">    
                <div class="card">
                    <div class="card-image">
                        <img src="{{$product->imagem}}">
                        <a class="btn-floating halfway-fab waves-effect waves-light red"><i class="material-icons">visibility</i></a>
                    </div>
                    <div class="card-content">
                        <span class="card-title">{{$product->nome}}</span>
                        <p>{{$product->descricao}}</p>
                    </div>
                </div>    
            </div>
        @endforeach

        Mudamos para m4 as cols para melhorar o front que tava muito zuado pelo fato de cada card está com uma quantidade de texto diferentes

        MAS, isso não é problema podemos limitar a quantidade de caracteres com a classe Str (nossa classe de manipulação de Strings). Ficando:

            {{ Str::limit($product->descricao, 20, '...') }}

            Isso vai limitar o conteúdo a 100 caracteres e colocar '...' reticcências quando chegar em 100 caracteres

******************************************************************************
PAGINAÇÃO DE RESULTADOS

Como queríamos todos os registros de nosso banco de dados usamos o ::all mas agora que queremos uma paginação vamos usar o ::paginate(3) informando quantos itens queremos por página

1. Então usamos o método paginate no nosso ProdutoController
2. Vamos criar a navegação entre as páginas em nossa view home

    <div class="row">
        {{ $produtos->links() }}
    </div>

    criamos outra row para organizar e usamos o método links(), ele já retorna pra gente um componente de navegação. Mas ele não vai vir muito bonito porque seu estilo veio compatível com TailWind ao invés de Materialize.

    Então se tivéssemos usando o TailWind beleza, mas sem estarmos vamos precisar criar uma view específica só para a navegação. Vamos copiar uma pronta p/ ganhar tempo

    - Primeiro criamos uma pasta chamada custom na pasta view, dentro cria o arquivo pagination.blade.php e cola o código pronto
    - Agora no métodos links passamos o caminho de nossa view customizada:

        <div class="row center">
            {{ $produtos->links('custom.pagination') }}
        </div>

        o center foi usado para centralizar nossa navegação

******************************************************************************
CRIANDO O SITE CONTROLLER

Até aqui estamos usando o nosso controller resource para o nosso site, isso não é errado, mas vamos criar um controller só para o site e deixar os resource para a parte de gerência (CRUDS)
Então vamos criar o siteController: php artisan make:controller siteController

Depois atualizamos o arquivo web de rotas para definir uma rota get para esse novo controle na rota '/' e colamos o conteúdo no index() do ProdutoController neste SiteController

******************************************************************************
LISTAGEM DE UM ÚNICO PRODUTOS

Agora no arquivo de rotas vamos criar uma rota para uma página que mostrará os detalhes de apenas um produto:

    Route::get('/produto/{slug}', [SiteController::class, 'details'])->name('site.details');

    A nossa rota é no /produto passando um parâmetro chamado slug para o nosso SiteController no método details que criaremos agora:

    public function details($slug){
        $produto = Produto::where('slug',$slug)->first();
        return view ('site.details', compact('produto'));
    }

    No SiteController vai receber um slug via parâmetro para a função details, vai buscar no banco de dados o registro onde o slug vai ser igual a slug.
    O ->first() garante que o resultado vai ser apenas um registro

    ATENÇÃO, É NECESSÁRIO USAR O FIRST, DO CONTRÁRIO NÃO SERÁ POSSÍVEL OBTER O OBJETO DO REGISTRO

Na home precisamos colocar um href no botão do card para entrar na rota details faremos isso especificando o nome da rota:

    <a href="{{ route('site.details', $product->slug) }}" class="btn-floating halfway-fab waves-effect waves-light red"><i class="material-icons">visibility</i></a>

Também precisaremos criar uma view para os detalhes do produto

    @extends('site.layout')
    @section('title','Detalhes')

    @section('conteudo')

        <div class="row container">
            <div class="col s12 m6">
                <img src="{{$produto->imagem}}" class="responsive-img">
            </div>

            <div class="col s12 m6">
                <h1>{{$produto->nome}}</h1>
                <p>{{$produto->descricao}}</p>
                <button class="btn orange btn-large">Comprar</button>
            </div>
        </div>

    @endsection

******************************************************************************
OneToMany Inverse / BelongsTo

Vamos lembrar os relacionamentos. Na tabela produtos temos o campo id_user e id_categoria simbolizando que um produto pertence a um usuário e uma categoria
Então este é um relacionamento de 1:n Inverso porque neste caso vamos listar a qual categoria e qual usuário aquele produto pertence

Para defirnirmos os relacionamentos é muito simples, vamos por exemplo definir o relacionamento entre produto e usuário

1. Vamos abrir o model Produto e criar um método chamado user que retornará o usuário a qual ele pertence:

    public function user(){
        return $this->belongsTo(User::class, 'id_user');
    }

2. Agora em nossa view de detalhes vamos colocar um novo parágrafo p/ mostrar o usuário a qual o objeto pertence:

    <p>Postado por: {{$produto->user->firstName}}</p>

    acessamos o valor de user que é o usuário a qual o objeto pertence e depois encadeamos no nome do atributo/coluna que queremos exibir, neste caso o primeiro nome

    Da mesma forma podemos fazer com Categoria

******************************************************************************
CATEGORIAS DINÂMICAS COM VIEWSHARE

Vamos criar um menu Dropdown no nosso navbar de modo que liste nossas categorias e ao clicar em uma delas, liste todos os produtos daquela categoria.

1. Criar o Dropdown, pegaremos um pronto no Materialize, a estrutura tem pronta lá, mas devemos ainda criar um JavaScript para ativar o Dropdown passando algumas opções de modificação

    const elemDrop = document.querySelectorAll('.dropdown-trigger');
    const instanceDrop = M.Dropdown.init(elemDrop, {
        coverTrigger: false,
        constrainWidth: false
    });

2. Vamos colocar uma setinha em nosso botão de dropdown, usamos a tag "i":

    <li><a class='dropdown-trigger' href='' data-target='dropdown1'>Categorias <i class="material-icons right">arrow_downward</i></a></li>

    Repare que na classe foi adicionado o "right" pra a seta se encaixar na direita, se fosse pra colocar na esquerda era "left"

3. Repare que não faz sentido a gente usar um método para buscar as categorias toda vez que quiser essa informação, porque essa é uma informação que vai se repetir, então a forma mais inteligente de fazer isso É
    ir no nosso AppServiceProvider.php (que é nosso provedor de serviços), e no método boot de inicialização a gente fazer uma única consulta por categorias, para isso:

    - Importa a Model Categoria
    - Usa o método ::all p/ fazer um select geral e colocar em um obj
    - Agora utilizamos o nosso método view() encadeando no share() passando o dado que vamos compartilhar para todas as nossas views. Ficando:

        public function boot()
        {
            $categoriaMenu = Categoria::all();
            view()->share('categoriaMenu',$categoriaMenu);
        }

    - Agora podemos acessar essa chave em todas as nossas views (ou seja, temos a informação de quais categorias possui no banco com apenas uma consulta).

4. Agora no layout.blade vamos usar um foreach para listar todas as nossas categorias dentro do DropDown:

    <ul id='dropdown1' class='dropdown-content'>
        @foreach ($categoriaMenu as $categoria)
            <li><a href="#!">{{$categoria->nome}}</a></li>            
        @endforeach
    </ul>

******************************************************************************
LISTAR PRODUTOS DE UMA CATEGORIA

1. O primeiro passo é criarmos uma nova rota para isso
2. A rota vai levar pra um método, então vamos criar um método para listar produtos de uma categoria em nosso SiteController
3. Lá no método, buscamos os produtos que fazem parte daquela categoria e depois retornamos uma view passando esse valor

    ATENÇÃO: ao usar o método ::all ele nos trás todos os registros mas se colocarmos alguma condição, precisaremos encadear no método get para conseguir pegar os resultados. Ficando:

    public function categoria($id){
        $produtos_categoria = Produto::where('id_categoria',$id)->get();
        return view ('site.categoria', compact('produtos_categoria'));
    }

4. Logo, precisamos criar uma view para renderizar o conteúdo desta listagem. E agora é só listar como preferir, para ganhar tempo vamos usar a mesma estrutura da home e adicionar só um title "Categoria:" e embaixo irá mostrar os cards. Vamos apagar só os links de paginação
5. Agora definiremos as rotas no dropdown do layout.blade, no href usamos o método route passando o nome da rota e o obj da categoria:

    <li><a href="{{ route('site.categoria',$categoriaM->id) }}">{{$categoriaM->nome}}</a></li>  

    mesmo que eu tivesse passado o objeto todo ao iinvés de só o id o método ainda ia conseguir identificar

6. Para paginarmos ao invés de usar o método get, devemos usar o paginate(x), pois são formas diferentes de tratar o objeto do Eloquent

******************************************************************************
MOSTRAR NOME DA CATEGORIA E PREÇO NUMBERFORMAT

1. Importamos o nosso Model categoria no SiteController.php
2. Usamos o método find() passando o $id e o Laravel busca a categoria de modo automático, depois jogamops a variável no compact
3. Agora basta usar no arquivo categoria.blade

Vamos exibir o preço na página de detalhes, mas repare que só exibir vai deixar o número não formatado então fazemos:

    R$ {{number_format($produto->preco, 2, ',', '.')}}

    O primeiro parâmetro do number_format é o número, o segundo são quantas casas decimais, o terceiro é o separador de casas decimais e o quarto é o separador de milhar

OBS: Para fazer funcionar o link do botão home no navbar, devemos especificar para qual rota ir no arquivo layout.blade, fazemos isso com:

    <li><a href="{{ route('site.index') }}">Home</a></li>

******************************************************************************
CARRINHO DE COMPRAS COM darryldecode/cart

Agora implementaremos um carrinho de compras em nossa aplicação utilizando a biblioteca darryldecode/cart

Mas antes de instalarmos essa biblioteca iremos executar o comando: composer self-update
Isso irá atualizar o próprio composer caso seja necessário

Agora deve ser instalada a lib e adicionada no array provides da config/app/php a linha: 
    Darryldecode\Cart\CartServiceProvider::class

E no array aliases a linha:

    'Cart' => Darryldecode\Cart\Facades\CartFacade::class

Agora vamos criar um controller para nosso carrinho: php artisan make:controller CarrinhoController

Agora vamos criar um método para lista todos os produtos de nosso carrinho

    public function carrinhoLista() {
        
    }

Só que para essa action ser executada precisamos implementar a rota que levará até ela

    - Primeiro importa o controller com: 
    
        use App\Http\Controllers\CarrinhoController;

    - E depois cria a rota com: 
    
        Route::get('/carrinho', [CarrinhoController::class, 'carrinhoLista'])->name('site.carrinho');

Podemos usar o getContent para obter o conteúdo do carrinho e o dd (Die and Dump) para debugar na tela:

    public function carrinhoLista() {
        $itens = \Cart::getContent();
        dd($itens);
    }

******************************************************************************
ADICIONANDO ITENS AO CARRINHO

1. Criaremos mais uma rota para adicionar itens ao carrinho:

    Route::post('/carrinho', [CarrinhoController::class, 'adicionaCarrinho'])->name('site.addCarrinho');

    Repare que o nome da rota pode ser o mesmo da outra porque o verbo é diferente, então temos uma rota get e uma post ao mesmo tempo com o mesmo nome

2. Criaremos a função que adiciona um item ao carringo, usamos o \Cart::add e passamos um array, porém, para passarmos asn informações do produto vamos colocar como parâmetro desta funcão uma instância de
    nossa requisição HTTP, pois assim todas as informações da requisição ficarão disponíveis em um objeto de fácil acesso:

    public function adicionaCarrinho(Request $request) {
        \Cart::add([
            'id' => $request->id,
            'name' => $request->name,
            'price' => $request->price,
            'quantity' => $request->qtd,
            'attributes' => array(
                'image' => $request->img
            )
        ]);
    }

    As chaves deste array passado no add já são definidos pela lib então tem que seguir o padrão, no attributes podemos passar um array com alguns valores a mais como uma imagem por Exemplo (valores que não são das chaves padrão)

    Agora para que seja possível receber esses valores na requisição, ela tem que ser feita em um momento específico e estratégico. Por exemplo, na hora de clicar no botão de comprar na página de
    detalhes de um produto. Pois assim a requisição terá os valores do produto em questão e a função do controller conseguirá adicioná-lo ao carrinho

3. Vamos lá no details.blade e colocamos o botão de comprar dentro de um form, pois assim colocamos um action no form para redirecionar para a rota Post que executará o nosso Controller
4. Além disso, precisamos colocar uma diretiva dentro do formulário (@csrf). Com isso o Laravel vai gerar um input do tipo hidden com um token para proteger nossa aplicação
5. Também devemos criar os dados que vão ser passados na requisição, então criaremos inputs com esses valores dentro e os nomes igual foram usamos na action do controller

    <form action="{{ route('site.addCarrinho') }}" method="POST" enctype="multipart/form-data">
        @csrf
        <input type="hidden" name="id" value="{{$produto->id}}">
        <input type="hidden" name="name" value="{{$produto->nome}}">
        <input type="hidden" name="price" value="{{$produto->preco}}">
        <input type="number" name="qtd" value="1">
        <input type="hidden" name="img" value="{{$produto->imagem}}">
        <button class="btn orange btn-large">Comprar</button>
    </form>

******************************************************************************
ESTILIZANDO CARRINHO E EXIBINDO ITENS

1. Vamos criar a view carrinho.blade.php com a estrutura do categoria.blade
2. Vamos alterar algumas informações como o título, e a estrutura invés de cards vamos usar tabelas para o carrinho (só pegar o código da tabela no materialize)
3. Depois ajusta as colunas e linhas definindo o que vamo querer que apareça e criamos uma coluna para as ações, assim será possível mudar quantidade e remover um produto do carrinho
4. Na função que estávamos debugando o conteúdo do carrinho vamos renderizar a view do carrinho

    public function carrinhoLista() {
        $itens = \Cart::getContent();
        return view ('site.carrinho', compact('itens'));
    }

5. No carrinho basta usar o foreach para percorrer os itens passados pelo compact e ir criando linhas na tabela

    - Encadeando o ->count() após o getContent podemos contar quandos produtos tem no carrinho
    - Podemos usar botões prontos do materialize para as ações

******************************************************************************
RedirectWith

Vamos mostrar uma mensagem quando um produto for adicionado com sucesso no carrinho e em seguida redirecionar, porque até então após o post estamos ficando em uma tela em branco. Fazemos isso com:

    return redirect()->route('site.carrinho')->with('sucesso', 'Produto adicionado no carrinho com sucesso!');

    usamos o redirect para redirecionar, encadeamos o route e especificamos qual o nome da rota que iremos, depois encademaos no with e damos um titulo e uma mensagem para ser exibida.
    Mas para essa mensagem ser exibida precisamos preparar a nossa view da rota carrinho para mostrar esta mensagem

    Então podemos colocar um if verificando a existência da mensagem, se existir mostra ela. Fazemos isso assim: 

        @if ($mensagem = Session::get('sucesso'))
            {{ $mensagem }}
        @endif

        O que está acontecendo aqui é buscarmos na sesão uma variável chamda sucesso (que foi passada com o with), se ela existir coloca em uma variável chamada $mensagem e depois exibimos ela. Senão não faz nada.

Isso já vai funcionar, mas vamos estilizar essa mensagem colocando ela dentro de um card, ficando:

    @if ($mensagem = Session::get('sucesso'))
        <div class="card green">
            <div class="card-content white-text">
              <span class="card-title">Já é quase seu...</span>
              <p>{{ $mensagem }}</p>
            </div>
        </div>
    @endif

Agora queremos que no nome carrinho do navbar seja exibido a quantidade de itens do carrinho

    - Para isto, vamos simplesmente usar o getContent()->count() no layout.blade, mas colocaremos em um span com uma classe badge (que cria um bloquinho sepado pra estilizar):


******************************************************************************
Removendo itens do carrinho

1. Criar rota para remover item do carrinho

    Route::post('/remover', [CarrinhoController::class, 'removeCarrinho'])->name('site.removeCarrinho');

2. Agora vamos criar nosso método no CarrinhoController:

    public function removeCarrinho(Request $request){
        \Cart::remove($request->id);
        return redirect()->route('site.carrinho')->with('product-removed', 'Produto removido do carrinho com sucesso!');
    }

    Criei esse with com 'product-removed' porque eu queria criar uma estilização diferente para a mensagem de quando removesse um produto do carrinho, mas poderia ser reaproveitado último

3. E por fim colocar o botão dentro de um form pra ele redirecionar para a rota com os dados necessários:

    <form action="{{ route('site.removeCarrinho') }}" method="POST" enctype="multipart/form-data">
        @csrf
        <input type="hidden" name="id" value="{{$item->id}}">
        <button class="btn-floating waves-effect waves-light red"><i class="material-icons">delete</i></button>
    </form>

******************************************************************************
Atualizar quantidade de itens do carrinho

1. Criar uma rota p/ atualizar a quantidade de um item do carrinho:

    Route::post('/atualizar', [CarrinhoController::class, 'atualizaCarrinho'])->name('site.atualizaCarrinho');

2. Criar o método que vai atualizar essa quantidade:

    public function atualizaCarrinho(Request $request){
        \Cart::update($request->id, [
            'quantity' => [
                'relative' => false,
                'value' => $request->quantity
            ]
        ]);
        return redirect()->route('site.carrinho')->with('sucesso', 'Quantidade atualizada com sucesso!');
    }

3. Agora vamos configurar o formulário que vai pegar o valor do input de quantidade e adicionar lá na rota:

    {{-- BTN ATUALIZAR --}}
    <form action="{{route('site.atualizaCarrinho')}}" method="POST" enctype="multipart/form-data">
        @csrf
        <input type="hidden" name="id" value="{{$item->id}}">
        <td><input style="width: 40px; font-weight:900;" class="white center" type="number" name="quantity" value="{{ $item->quantity}}"></td>
        <td>
        <button class="btn-floating waves-effect waves-light orange"><i class="material-icons">refresh</i></button>
    </form>

******************************************************************************
Limpando Carrinho

1. Vamos criar uma rota para limpar o carrinho (pode ser do tipo GET mesmo porque não vamos precisar passar nenhuma informação já que vamos apagar tudo):

    Route::get('/limpar', [CarrinhoController::class, 'limparCarrinho'])->name('site.limparCarrinho');

2. Criar o método no controller:

    public function limparCarrinho(){
        \Cart::clear();
        return redirect()->route('site.carrinho')->with('aviso', 'Seu carrinho está vazio!');
    }

    O clear() vai limpar o carrinho

3. Agora para linkar isso no botão, ao invés de colocar em um formulário dessa vez vamos mudar o button para "<a>" e usar o href para redirecionar para a /limpar

    a href="{{route('site.limparCarrinho')}}" class="btn waves-effect waves-light blue"> Limpar carrinho<i class="material-icons right">clear</i></a>

******************************************************************************
Fazendo alguns ajustes Finais no carrinho de compras

1. Se não houver nenhum produto, não há necessidade de exibir uma tabela vazia:

    - Então criamos um @if para verificar com o count() do carrinho está vazio, se sim mostra um aviso, se tiver produtos exibe o carrinho

2. Tá dando para colocar valores negativos nas quantidades de itens:

    - colocar a função de absolut abs() do php, módulo do número, tanto na hora de add quanto de atualizar produto na requisição
    - colocar o atributo min="1" nas tags htmls do details e do carrinho

    Dessa maneira o front não vai deixar que passe valores negativos, mas mesmo que passe o back-end vai tratar para que ele fique positivo

3. Vamos exibir o valor total de nosso carrinho, basta usar o \Cart::Total() que já calcula o valor total. Mas vamos colocar em um card para ficar mais bacana:

    <div class="card orange">
        <div class="card-content white-text">
          <span class="card-title" style="font-weight: bold">TOTAL: R$ {{ number_format(\Cart::getTotal(),2,',','.')}}</span>
          <p>Pague em até 12x sem juros!</p>
        </div>
    </div>

******************************************************************************
AUTENTICAÇÃO SIMPLES

Vamos criar nossa autenticação manualmente

1. Criar um controller para nosso sistema de login

    php artisan make:controller LoginController

2. Importaremos no controller a nossa classe de autenticação

    use Illuminate\Support\Facades\Auth;

3. Criaremos o método que fará a autenticação, e como vamos receber o email e senha, via post, do usuário que for se autenticar, vamos colocar como parâmetro a instância da requisição

    public function auth(Request $resquest){
        $credenciais = $request->validate([
            'email' => ['required', 'email'],
            'password' => ['required']
        ]);

        if(Auth::attempt($credenciais)){
            $request->session()->regenerate();
            return redirect()->intended('dashboard');
        }else{
            return redirect()->back()->with('mensagem', 'Usuário ou senha inválido.');
        }

    }

    - repare que criamos uma variável e encadeamos o método validate no objeto da requisição, isso serve para fazer validações dos valores antes de tentarmos autenticar
    - para o email, exigimos que fosse require (não pode está vazio) e fosse do tipo email (seguir os padrões de ter @ e etc)
    - para a senha simplesmente dissemos que deve ser obrigatória

    - depois de fato fizemos a autenticação, usamos a classe Auth e seu método attempt para realizar a autenticação com a nossa variável $credenciais que já possui os valores de email e senha validados,
      se a autenticação for feita com sucesso, então geramos um id para a sessão com o session()->regenerate() e em seguida redirecionamos a página usando o intended()

      intended('default'): ele vai redirecionar para a página que estava antes, mas se não for possível redireciona para a que for passada como parâmetro

    - e caso a autenticação não for reealizada com sucesso a página simplesmente redireciona de volta para a página naterior e passa com o with() uma mensagem de erro.

******************************************************************************
VALIDAÇÕES

Primeiramente vamos na pasta de views e criar uma pasta chamada login e dentro uma viem chamada form.blade.php

1. Criamos um formulário para realizar login

    @if($error = Session::get('error'))

        {{ $error }}

    @endif

    <form action="{{ route('login.auth') }}" method="POST" >
    @csrf

        Email: <input type="email" name="email"><br>
        Senha: <input type="password" name="password"><br>

        <button type="submit">Entrar</button>

    </form>

2. Criamos tanto a rota que vai exibir o formulário quanto a rota que vai processar o nosso post de login

    - No caso como uma dessas rotas é só para mostrar uma view, nem precisamos passar por um controller, já podemos direto fazer a rota retornar uma view

        Route::view('/login', 'login.form')->name('login.form');

    - agora criaremos uma rota do tipo post que vai validar o login (vai ser o controller auth)

        Route::post('/auth', [LoginController::class, 'auth'])->name('login.auth');

3. Perceba agora que ao colocar um email e senha que não está na base de dados vai mostrar a mensagem de erro, mas se não passarmos nada não vai mostrar nada. Isso ocorre porque devemos tratar os erros advindos da validação

    @if ($errors->any())
        @foreach ($errors->all() as $error)
            {{$error}} <br>
        @endforeach
    @endif

    Deste modo, caso tenha sido gerado algum erro não importa qual, vai entrar no if, e então faremos um foreach percorrendo todos os erros e exibindo na tela.

    Caso queira personalizar as mensagens de erro do validate() basta pasar um outro array onde a chave é nome nome do campo.validacao

        $credenciais = $request->validate([
            'email' => ['required', 'email'],
            'password' => ['required']
        ],[
            'email.required' => 'O e-mail é obrigatório.',
            'email.email' => 'O e-mail precisa ser válido.',
            'password.required' => 'A senha é obrigatória.',
        ]);

4. Se tentarmos nos autenticar com com um login e senha que está no banco, já vai funcionar. Só que vai dar 404 pois ainda não criamos a nossa rota dashboard

******************************************************************************
REDIRECIONANDO PARA O DASHBOARD

Agora precisamos criar a nossa rota dashboard, o nosso controller e a nossa view

1. Criamos a rota (já deve ter sido gerado o Controller antes):

    Route::get('/admin/dashboard', [DashboardController::class, 'index'])->name('admin.dashboard');

2. Vamos criar o método index no Controller a princípio só exibindo a view 'admin.dashboard'
3. Agora criamos a view dashboard

******************************************************************************
EXIBINDO DADOS DO USUÁRIO

A partir de nosso método Auth conseguimos recuperar os dados do usuário que está autenticado sem precisar importar nada (ou seja, após autenticado o auth fica disponível em qualquer view), ex:

    <h1>Olá, {{ auth()->user()->firstName }}.</h1>

    uso o auth() encadeio no usuário por exemplo, e depois no campo que quero recuperar

Por exemplo, podemos ir lá na nossa come e criar um novo menu no navbar que mostrar o nome de quem tá logado e um dropdown

    <ul id="nav-mobile" class="right">
        <li><a class='dropdown-trigger' href='' data-target='dropdown1'>Olá, {{auth()->user()->firstName}} <i class="material-icons right">arrow_downward</i></a></li>
    </ul>

******************************************************************************
LOGOUT

Precisamos criar um botão de logout no nosso dropdown de funções do usuário, e também essa funcionalidade

Então no controller vamos criar um método logout que recebe como parâmetro o Resquest da requisição (pra deslogar não precisa passar nada, só Auth::logout()) mas passamos resquest para invalidar a sessão que estava ativar (porque se não fizer isso
e alguem tiver copiado os cookies vai conseguir logar mesmo depois de ter apertado o botão de logar se clonar o cookie anterior)

Ficando:

    public function logout(Request $request){
        Auth::logout();
        $request->session()->invalidate();
        $request->session()->regenerateToken();
        return redirect('/');
    }

    - Primeiro deslogamos
    - Segundo invalidamos a sessão
    - Geramos um novo token para a sessão
    - Redirecionamos a página para o index

    se quiser passar o nome da rota ao invés do path pode usar o route:

        return redirect(route('site.index'));

Também não pode esquecer de criar a rota:

    Route::get('/logout', [LoginController::class, 'logout'])->name('login.logout');

Agora só tem mais um problema, vai dar erro porque o menu de usuário que criamos para o usuário no layout.blade está mostrando informações de um usuário autenticado que não existe. 
Então utilizaremos a diretiva @auth para o bloco só aparecer quando tiver uma sessão ativa, e um @else antes de sair da diretiva auth para mostrar um botão de login caso ninguém esteja logado. Ficando:

    <ul id="nav-mobile" class="right">
        @auth
        <li><a class='dropdown-trigger' href='' data-target='dropdown2'>Olá, {{auth()->user()->firstName}} <i class="material-icons right">arrow_downward</i></a></li>
        @else
        <li><a href="{{ route('login.form') }}">Login<i class="material-icons right">login</i></a></li>
        @endauth
    </ul>

******************************************************************************
MIDDLEWARES

São filtros de requisição HTTP, o Laravel já disponibiliza alguns, inclusive o de autenticação. Mas também podemos criar os nossos middlewares.

É no arquivo Http/Kernel.php que os middlewares são definidos, eles podem ser divididos em grupos ou individuais.

Como aplicamos um Middleware? 

    - Pode aplicar na rota: basta encadear o método middleware diretamente na criação da rota no arquivo web.php

        Route::get('/admin/dashboard', [DashboardController::class, 'index'])->name('admin.dashboard')->middleware('auth');

        Encadeamos o middleware de autenticação na nossa rota da página do administrador, vamos só mudar o argumento de direcionamento da rota no arquivo do middleware para que caso não tenha ninguém logado levar para a rota login.form

    - Também podemos aplicar em um Controller

        Basta dentro do controller colocar um método construtor que encadeia o This (a instância) com o middleware

        public function __construct(){
            $this->middleware('auth');
        }

    - Podemos aplicar em métodos específicos invés de aplicar a classe toda. Deste modo, ainda no construtor, encadearíamos com o only e espeficaríamos o método que usaria o middleware:

        public function __construct(){
            $this->middleware('auth')->only('index');
        }

        poderia ser um array de métodos, ex: ['index','home','contato']

    - Também podemos aplicar a todos com exceção de algum usando o ->except('')

******************************************************************************
CRIANDO OS MIDDLEWARES

Usamos: php artisan make:middleware CheckEmail

Depois registramos no arquivo Kernel.php lá na routeMiddleware:

    'checkemail' => \App\Http\Middleware\CheckEmail::class,

Agora dentro do middleware vamos verificar se o email do usuário é do tipo gmail:

    1. O método handle da forma como vem asism que criado não faz nada, simplesmente passa para a frente a requisição sem nenhum filtro

        public function handle(Request $request, Closure $next)
        {
            return $next($request);
        }

        O middleware serve justamente para montarmos um filtro, então vamos criar a nossa condição

    2. Primeiramente vamos verificar se tem alguem logado, caso não tenha já vamos redirecionar para a página de login

        if(!auth()->check()){
            return redirect(route('login.form'));
        }

    3. Agora vamos pegar o email da requisição e verificar se de fato é gmail ou não

        $email = auth()->user()->email;
        $data = explode('@', $email);
        $data = explode('.',$data[1]);

        $servidorEmail = $data[0];

        if ($servidorEmail != 'gmail') {
            return redirect((route('login.form')));
        }

    Desse modo se não cair em nenhuma das duas verificações, ele vai proceder com a solicitação http. E para usarmos o middleware basta acrescentá-lo na rota, ex:

    ->middleware(['auth','checkemail'])

******************************************************************************
REGISTER

Agora precisamos criar um formulário para os nossos usuário se registrarem em nosso sistema

1. Vamos criar uma view na pasta login chamada create.blade.php com a mesma estrutura do form de cadastro como modelo
2. Dentro vamos criar um form com todos os campos necessários, neste form vamos colocar o action para 'users.store' pois logo iremos criar um controller que gerenciará toda a lógica relacionada ao cadastro do usuário

    Os names dos campos colocaremos iguais ao banco de dados (para facilitar, mas não é obrigado fazer isso, Faremos por boas práticas)

3. Agora criaremos o nosso controller UserController do tipo resource

    php artisan make:controller UserController -r

    Sendo do tipo resource já irá vir com alguns métodos prontos, e um deles é o STORE que será responsável por pegar todos os dados do formulário

4. Agora iremos recuperar os dados do formulário em nosso Controller:

    No método store...

        $user = $request->all(); // Pega todos os campos e coloca em um array
        $user['password'] = bcrypt($request->password); // criptografa a senha para salvar no banco

    Devemos lembrar de importar a Model (só não vamos criar porque ela já está criada)

    Em seguida criamos o usuário no banco com:

        $user = User::create($user);

    Agora já iremos fazer o login para o usuário recém criado:

        - Importamos o Auth (nossa classe de autenticação)

        - Fazemos o login do usuário com:
            Auth::login($user);
            Passando a instância do usuário

        - Redirecionamos para a dashboard:
            return redirect()->route('admin.dashboard');

5. Agora criaremos a rota que renderiza a view de cadastro:

    Route::get('/register', [LoginController::class, 'create'])->name('login.create');

    Para isso, devmos criar o método create dentro do LoginController

6. Criaremos a nossa rota resource, primeiro importamos o controller e depois criamos a rota:

    Route::resource('users', UserController::class);

******************************************************************************
REMEMBER

Vamos implementar aquela função de permanecer logado no site.

1. Criar um checkbox na view com o formulário de login

    <input type="checkbox" name="remember"> Lembrar-me<br>

2. Vamos recuperar esse dado no LoginController

    Agora basta adicionar o valor dentro da função attempt pois o laravel já tem esse funcionalidade pronta.

    if(Auth::attempt($credenciais, $request->remember)){}

    Isso fará com que seja criado um cookie remember_web (que vai ser o gatinho da autenticação para verificar se o usuário autenticado foi lembrado)

Os cookies e token de sessão expiram muito rápidos, então se o usuário ficxar muito tempo sem entrar no site o site vai deslogar, mas com o remember_token a data de expiração é de mais de uma ano, logo quando o usuário for tentar logar 
no site não terá o token e o id de sessão mas terá o remember, ent o sistemas irá conferir no banco se o token do remember é válido e se for ele irá gerar novos cookies de sessão e logar automaticamente o usuário.

******************************************************************************
AUTORIZAÇÃO COM GATE

Já aprendemos sobre autenticação, agora vamos abordar AUTORIZAÇÃO

Por exemplo, vamos fazer com que só seja possível ver os detalhes de um produto apenas para quem cadastrou ele.

Para isso, uma maneira de resolver pode ser utilizando os Gates

1. Dentro de Providers, temos o AuthServiceProvider.php, e dentro tem o método boot(). Lá vamos definir uma regra

    Gate::define('ver-produto', function(User $user, Produto $produto){
        return $user->id == $produto->id_user;
    });

    Com isso, usando o método define da classe Gate, vamos dar um nome 'ver-produto' e uma função de callback. Neste função vamos pendurar nela duas variáveis que vão ser as intâncias das models do usuário e do produto.

    Agora fazer um retorno a condição que deixará a regra verdadeira. Neste caso, queremos que o id do usuário que criou determinado produto seja o mesmo id do usuário que está autenticado. Pois assim garantiremos
    que só o criador de um determinado produto conseguirá passar por essa regra.

    - Lembrar de importar as models no AuthServiceProvider
    - Importar o Gate no SiteController, que é onde está o método de exibir os detalhes de um produto

2. Para adicionar o gate no método details basta adicionar a linha:

    Gate::authorize('ver-produto', $produto);

    Ele já vai tentar realizar a autorização do $produto com o Gate 'ver-produto' e já captura automaticamente o usuário logado dentro do Gate.

******************************************************************************
AUTORIZAÇÃO COM POLICIES

É uma outra maneira de fazermos a autorização

1. Criaremos o policy

    php artisan make:policy ProdutoPolicy

2. Agora basta criar as nossas regras dentro do policy, mesma lógica do outro só que dentro de um método

    public function verProduto(User $user, Produto $produto){
        return $user->id == $produto->id_user;
    }

3. Precisamos registrar o nosso Policy, para isso:

    - No AuthServiceProvider tem um array de $policies onde lá ficam todas as relações de model e com qual policy ele está associado

        'App\Models\Produto' => 'App\Policies\ProdutoPolicy',

    - Mais para baixo no método boot() tem uma linha com o conteúdo:

        $this->registerPolicies();

        Esta linha registra todos os policies que estão naquele array. (NÃO PRECISA MAIS DA LINHA QUE DEFINIA UM GATE)

4. Agora vamos de fato autorizar:

    Lá no detail invés do Gate::authorize vamos usar apenas

    $this->authorize('verProduto', $produto);

E pronto, já vamos estar fazendo a autorização com Policies

******************************************************************************
RESTRINGINDO RECURSO NA VIEW COM CAN E CANNOT

Se não vamos deixar os usuário que não são os criadores dos produtos ver eles então não faz sentido deixar visível aquele ícone de olhingo que clica e entra na rota de details, então vamos restringir este recurso

Então vamos restringir este recurso para quem não estiver autorizado e para quem não tiver autenticado

Precisamos escolher entre Gate ou Policy, mas na hora de restringir no arquivo blade, vamos usar a diretiva @can('nomeRegra', $objeto)

    @can('verProduto', $product)
    <a href="{{ route('site.details', $product->slug) }}" class="btn-floating halfway-fab waves-effect waves-light red"><i class="material-icons">visibility</i></a>
    @endcan

    Por exemplo aqui eu coloquei o nome da regra da policy e passei a instância do produto (lembrando que como o policy é um provider, não precisamos nem importar nada porque todas as views já reconhecem ele)

Pense comigo, se na lógica da regra só vai dar true se o usuário for o mesmo que criou o produto, logo a regra já abrange não só o criador do produto mas também se tem alguém autenticado, porque quando não tiver ninguém autenticado
esse ninguém não terá um id para combinar com o do produto

Também pode ser adicionado um else para caso queira exibir algum conteúdo se o usuário não estiver autorizado


Assim como tem o CAN, também temos o CANNOT que é o seu inverso (vai exibir o conteúdo se o usuário não tiver autenticado, e com else mostra se ele tiver autenticado)

******************************************************************************
#70 Restrigindo acesso com Allows e Denies, Can e Cannot

Assim como restringimos conteúdos nas views, também podemos fazer isso nos controllers

Vou retirar o CAN do home.blade só para aparecer o botão de entrar na details para todos.

Maneira utilizando Allows e Denies | Vou criar duas condições:

    if (Gate::allows('ver-produto', $produto)) {
        return view('site.details', compact('produto'));
    }

    if (Gate::denies('ver-produto', $produto)) {
        return redirect()->route('site.index');
    }

    - A primeira vai autorizar a renderização da view details caso passe pela a regra
    - A segunda vai entrar no if caso não seja autorizado (não passe pela regra), e assim vai redirecionar de volta para a home

Maneira utilizando CAN e CANNOT | Vou criar duas condições:

    if (auth()->user()->can('verProduto', $produto)) {
        return view('site.details', compact('produto'));
    }

    if (auth()->user()->cannot('verProduto', $produto)) {
        return redirect()->route('site.index');
    }

    - A primeira vai autorizar a renderização da view details caso passe pela a regra da Policy
    - A segunda vai entrar no if caso não seja autorizado (não passe pela regra), e assim vai redirecionar de volta para a home

Repare que deste segundo modo, estamos utilizando o auth()->user() para depois encadear o can, se você pensar bem. Quando não tiver ninguém logado e clicar no botão, invés de redirecionar vai dar um erro porque se nem existe usuário autenticado 
como daria pra encadear um outro método, então para evitar isso podemos fazer um if antes verificando se tem alguém conectado e se não tiver redirecionar para o site.index