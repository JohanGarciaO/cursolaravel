******************************************************************************
LARAVEL

// Diretório que armazena todas as entidades do Laravel
use Illuminate\Http\Request

Laravel: nada mais é do que uma abstração de códigos em comum (Utiliza o padrão MVC)

O Laravel tem diversos serviços já prontos para serem utilizados, estes serviços ficam na pasta /vendor/laravel/framework/src



******************************************************************************
ROTAS

// Verbo GET permite obter o request de uma requisição
Route::get('/', function () {
    return view('welcome');
});

// Verbo ANY não muito comum mas permite qualquer tipo de requisição http nesta rota
Route::any('/any', function () {
    return "Permite todo tipo de acesso HTTP (get, post, put, delete...)";
});

// Verbo MATCH é o inverso do ANY, o match permite apenas requisições dos tipos predefinidas no primeiro parâmetro
Route::match(['put', 'post'], '/match', function () {
    return "Permite apenas acessos definidos";
});

// Passagem de parâmetro nas rotas (sem interrogação aquele parâmetro fica obrigatório)
Route::get('produto/{id}/{cat?}', function ($id, $cat = 'Categoria não definida') {
    return "O id do produto é: $id<br>A categoria é: $cat";
});

// Redirecionamento de Rotas
// Route::get('sobre', function () {
//     return redirect('/empresa');
// });

// Redirecionamento de Rotas usando o verbo REDIRECT
Route::redirect('/sobre', '/empresa');

// Renderiza uma view sem precisar colocar dentro de uma função de callback de uma rota do tipo GET
Route::view('/empresa', '/site/empresa');

// ROTAS NOMEADAS -> é feito o redirecionamento através do NOME da rota e não da rota em si, desta maneira, se a rota for modificada e o nome não, o redirecionamento continuará sendo feito para o novo endereço de rota
Route::get('/timesnownews', function () {
    return view('news');
})->name('noticias');

Route::get('/novidades', function () {
    return redirect()->route('noticias');
});

******************************************************************************
GRUPO DE ROTAS

// Agrupar todo mundo pelo prefixo da rota
Route::prefix('admin')->group(function () {
    Route::get('/dashboard', function () {
        return "dashboard";
    });

    Route::get('/users', function () {
        return "users";
    });

    Route::get('/clientes', function () {
        return "clientes";
    });
});

// Agrupar todo mundo pelo prefixo do nome
Route::name('admin.')->group(function () {
    Route::get('admin/dashboard', function () {
        return "dashboard";
    })->name('dashboard');

    Route::get('admin/users', function () {
        return "users";
    })->name('users');

    Route::get('admin/clientes', function () {
        return "clientes";
    })->name('clientes');
});

// Agrupar todo mundo pelo tanto prefixo da rota quanto do nome, ou qualquer outro tipo de agrupamento (lembrando que a chave para o prefixo do nome utilizando o Route::name é o name mas utilizando o group é o "as")
Route::group([
    'prefix' => 'admin',
    'as' => 'admin.'
], function () {
    Route::get('dashboard', function () {
        return "dashboard";
    })->name('dashboard');

    Route::get('users', function () {
        return "users";
    })->name('users');

    Route::get('clientes', function () {
        return "clientes";
    })->name('clientes');
});

******************************************************************************
CONTROLLERS

Para criar um Controller (nome em Pascal Case): php artisan make:controller ProdutoController

Dentro do controller você escreve suas functions como por exemplo:
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class ProdutoController extends Controller
{
    public function index()
    {
        return "index";
    }
}


// Primeiro importa o Controller com o namespace
use App\Http\Controllers\ProdutoController;

// Depois cria uma rota onde o primeiro parâmetro é a rota e o segundo é o controller que vai responder por essa rota
Route::get('/', [ProdutoController::class, 'index']);

OBS: Os controllers utilizam o serviço Requests do Laravel, que:
Request: é um recurso para obter uma instância via injeção de dependência da solicitação http

// Passar parâmetros para responder um método de vizualização de produto
Route::get('/produto/{id?}', [ProdutoController::class, 'show'])->name('produto.show');

Obs: lembre se criar o método no controller, se quiser deixar opcional colocar o interrogação pós parâmetro, e definifir o valor nos parâmetros de ciração do método no controller
public function show($id = 0)
    {
        return "Show: " . $id;
    }

Obs: lembrando que é altamente recomendado definir nomes para as rotas


******************************************************************************
RESOURCE

Alguns recursos são tão genéricos que o framework (laravel, que busca ganho de tempo e agilidade) já considera disponibilizar com apenas uma linha de código,
Isso é o exemplo dos RESOURCES

Vamos apagar o ProdutoController antigo e criar novamente, agora com: php artisan make:controller ProdutoController --resource

Desta maneira o controller já vai vir com diversos métodos já pré configurados. São eles:

- index: para listar
- create: exibir um formulário
- store: salvar os registros que vamos receber via injeção de dependências através do Request
- show: exibir um recurso específico pelo id
- edit: exibir um formulário para edição de algum recurso
- update: para atualizar algum recurso
- destroy: para a gente remover algum recurso da base de dados

Logo, o Resource é uma mão na roda para manipulação de banco de dados

// Definindo a rota de um Resouce no web.php
Route::resource('produtos', ProdutoController::class);

Só em ir no navegador de colocar na rota Produtos já será retornado o método index sem precisar especificar

******************************************************************************
COMANDOS ROUTE

php artisan route:list -> PARA LISTAR AS ROTAS DE SUA APLICAÇÃO
route:cache -> Vai criar um arquivo de cache de rota para deixar a resposta de requisição mais rápida (não recomendado trabalhando em produção)
route:clear -> Remove o arquivo de Cache de Rotas

******************************************************************************
CONEXÃO COM O BANCO DE DADOS

No .env tem uma sessão de variáveis com um prefixo DB_ (elas representam os dados de conexão do banco de dados)

Também existe o arquivo config\database.php que possui um setup com vários valores defauls prontos para serem usados caso não sejem setados na .env

Obs: agora eu criei o DB cursolaravel através do HeideSQL e alterei o .env

******************************************************************************
MIGRATIONS -> é um recurso utilizado para manipulação de dados no DB

Na pasta database/migrations podemos observar que já vieram alguns arquivos prontos

2014_10_12_000000_create_users_table.php: cria uma tabela já de usuários
2014_10_12_100000_create_password_resets_table.php: reseta senha caso precise
2019_08_19_000000_create_failed_jobs_table.php: usado quando trabalhando com Fillas
2019_12_14_000001_create_personal_access_tokens_table.php: para trabalharmos com token

Obs.: O Laravel já trouxe esses quatro migrations prontos, mas é importante entender que esses migrations PRECISAM ser CRIADOS.

Portanto, observemos sua estrutura:

Todos possuem um método UP e um método DOWN,

UP: acionado quando o migration é executado (meio que cria toda a estrutura)

DOWN: acionado quando revertemos um migration


Podemos observar no migration que veio pronto de criação de tabela de usuários, que está sendo usádo o Método CREATE do Serviço SCHEMA
Ele está criando uma tabela chamada users e definindo as colunas desta tabela

public function up(){
    Schema::create('users', function (Blueprint $table) {
        $table->id();
        $table->string('name');
        $table->string('email')->unique();
        $table->timestamp('email_verified_at')->nullable();
        $table->string('password');
        $table->rememberToken();
        $table->timestamps();
    });
}


Comandos migrations:

php artisan migrate -> executa todos os migrations (cria todas as tabelas)

migrate:fresh -> deleta todas as tabelas e depois reexecuta todas as migrações
migrate:install 
migrate:refresh -> reseta e já reexecuta, ele meio que dar um reset e depois executa tudo
migrate:reset -> reverte todas as migrações (é tipo um rollback, mas de todas as migrações)
migrate:rollback -> desfaz o último migrate (a última migração)
migrate:status -> exibe o status de nossos migrations (o nome e se foi executado ou não)

E para criar nossas tabelas? Precisamos criar um migration (para o nome do migration use a convenção de Snake Case)
php artisan make:migration create_produtos_table

Ele vai criar o Migration com a estrutura prontinha, depois é só completar os campos
Obs.: se eu tivesse usado um nome aleatório (sem o prefixo do nome create e o sufixo table) o migration não ia identificar o que você precisa e entregaria os métodos up e down vazios

Mas se quiser criar um migration sem usar o prefixo e sufixo do nome e ainda assim ele vir com algumas coisas prontas como o outro, podemos criar o migrate da seguinte maneira:
php artisan make:migration produtos --create=produtos

Além de criar, também podemos editar estas tabelas, renomear , excluir...

Vamos criar um migration para alterar o nome da tabela produtudos:
    - php artisan make:migration alterar_nome_tabela_produtos
    - No método up() do migrate vamos colocar Schema::rename('produtos', 'produto'); e ao executar esse migrate o nome da tabela será renomeado

Os migrates são feitos para serem executados de forma sequencial, então uns podem depender de outros
Ex: não daria pra mudar o nome da tabela produtos se a tabela já não existisse previamente

Também podemos criar um migrate para apagar uma tabela, dentro do up vamos usar Schema::dropIfExists('produto');

Também conseguimos modificar as colunas via migrations, mas precisamos instalar uma dependência chamada doctrine/dbal (caso a versão do Laravel seja inferior a 11)

Copnseguimos criar tabelas e definir colunas, mas para modificar as colunas precisamos dessa lib

********* MODIFICANDO COLUNAS

Vou criar duas colunas no migration da tabela produtos
    $table->string('nomee');
    $table->string('nomecompleto');

Agora vamos modificar a coluna 'nomee' para 'nome' e apagar a outra

    Dentro do migration, vamos no Up() e definimos em Schema::table a tabela que vamos estar trabalhando e uma função de callback com o Blueprint passando para o objeto $table
    Obs: meio que o Blueprint gera uma instância da tabela e coloca no objeto table, modificamos esse objeto e depois o Blueprint efetiva as mudanças

    Blueprint: recurso de geração de código do Laravel

    Agora camos renomear a coluna e apagar a outra, o código fica:

    public function up()
    {
        Schema::table('produtos', function (Blueprint $table) {
            $table->renameColumn('nomee', 'nome');
            $table->dropColumn('nomecompleto');
        });
    }

******************************************************************************
MODELS

É a representação de uma entidade

Então vamos criar uma model com: php artisan make:model produto

Depois podemos criar um registro aleatório no banco na tabela produtos e vizualizar no index de nosso controle,
para isto, devemos ir na index de nosso ProdutoController e definir:

    $produtos = \App\Models\Produto::all();
    return dd($produtos);

Primeiro instanciamos o objeto produto usando o método all() que pegou todos os dados da tabela produto
depois retornamos a função dd($produto) passando o objeto, esta função debuga os dados de nosso objeto na tela

Este é um método do Eloquent (que é um ORM do Laravel)

ORM -> Object Relational Model, serve para mapear de modo automático uma tabela de um banco de dados para dentro de uma classe

OU SEJA, O MODEL SERVE PARA REPRESENTAR UMA TABELA (ENTIDADE)

Obs.: Observe que o Laravel é tão inteligente que nossa tabela se chama "produtos", criamos um model chamado "Produto" e ainda assim ele relacionou com a tabela.
MAS, caso não tivesse conseguido relacionar, deveriamos especificar o nome da tabela com o:

    - protected $table = 'produtos';

Alí na index do controller onde definimos o objeto $produtos passando o Path do Model, podemos resumir e colocar só Produto
Para isso basta colocar no início do arquivo um namespace com: use \App\Models\Produto;

******************************************************************************
CRIANDO TABELAS USERS, CATEGORIAS E PRODUTOS

1. Vamos deletar o migrate update_produtos
2. Vamos de fato definir a estrutura de nossa tabela

    public function up()
    {
        Schema::create('produtos', function (Blueprint $table) {
            $table->id(); // Cria um campo id (autoincrement, inteiro e primary key)
            $table->string('nome'); // campo nome do tipo string
            $table->text('descricao'); // campo descricao do tipo text
            $table->double('preco', 10, 2); // campo preco do tipo double com 2 casas decimais
            $table->string('slug'); // campo slub do tipo string
            $table->string('imagem')->nullable(); // campo imagem para armazenar o path de uma imagem (pode ser nulo)
            $table->unsignedBigInteger('id_user'); // campo que vai armazenar o valor da FK
            $table->foreign('id_user')->references('id')->on('users')->onDelete('cascade')->onUpdate('cascade'); // Cria o relacionamento da FK dizendo onde tá referenciando e qual tipo de relacionamento, neste caso 'cascade'
            $table->timestamps(); // cria dois campos: created_at e updated_at
        });
    }

    Como o Relacionamento é cascade se um usuário for deletado todos os produtos daquele usuário também será deletado
    
    Quabdo usamos estes métodos nas colunas/relacionamentos estamos encadeando uma propriedade...
    EX: 
        ->unique(): define aquela coluna com de valor único
        ->nullable(): permite valores nulos
3. Vamos criar os Models e Migrations necessários

    - Podemos criar tanto o model quanto o migration com um único comando:
        php artisan make:model Categoria --migration

    - Ou até mesmo ainda um controller (e do tipo resource se quiser):
        php artisan make:model Categoria --migration --controller --resource

    - Ou, mais resumidamente ainda:
        php artisan make:model Categoria -m -cr

    - Ou:
        php artisan make:model Categoria -mcr

4. Agora vou implementar um nome e uma descrição no migrate da categoria
5. Precisamos nos atentar ao fato de que os migrations foram feitos para serem executados de modo sequencial
    e por isso o nome deles possui uma data e uma numeração antes do nome de fato do migration.

    Portanto, sabendo que estamos usando agora chaves estrangeiras, da forma como geramos nosso código estamos
    criando um relacionamento com a tabela Categoria antes mesmo de criar a tabela. Então vamos resolver isso
    simplesmente alterando a ordem dos migrations mudando o nome.

******************************************************************************
SEEDER

Recurso que utilizamos para ganhar tempo na inserção de registros no banco de dados

Vamos criar um seeder para adicionar um usuário em nossa tabela

1. php artisan make:seeder UsersSeeder
    isso gerará o arquivo de seeder, que é bem simples e tem apenas um método (o run(), que é a ação de quando executado)
2. Precisamos fazer esta seeder conversar com o Model User, repare que:
    - Possui um array de atributos chamado fillable (define quais campos serão permitidos inserção em massa)
    Precisamos modificar pra deixar de acordo com as colunas que queremos modificar
3. Vamos IMPORTAR o Model no Seeder:
    use App\Models\User;

    assim poderemos usar o método User::create() para criar nossos usuários
4. Agora vamos implementar a criação de um usuário:

    public function run()
    {
        User::create([
            'firstName' => 'Johan',
            'lastName' => 'Garcia',
            'email' => 'contato@johan.com',
            'password' => bcrypt('12345678'),
        ]);
    }

5. Agora no DatabaseSeeder iremos utilizar o $this para passar um array com classes de Seeders que serão executadas
    
    public function run()
    {
        // \App\Models\User::factory(10)->create();
        $this->call([
            UsersSeeder::class,
        ]);
    }

******************************************************************************
FACTORY
-> Para que não precisemos inserir registro por registro e inserir alguns registros específicos em massa para testar

1. Vamos usar o Factory para gerar 5 categorias de forma automática

    - Primeiro vamos criar o Factory com: php artisan make:factory CategoriaFactory

2. Agora dentro da estrutura definition() vamos gerar uma estrutura modelo para ser executada p/ gerar o cadastro

    - A tabela cadastro possui o campo nome e descricao, então vamos colocá-los no Factory e usar o $this->fake p/ gerar registros falsos

    public function definition()
    {  return [
            'nome' => $this->faker->unique()->word, // gera uma palavra fake única      
            'descricao' => $this->faker->text,
        ];
    }

3. Agora precisamos criar um Seeder para executar este Factory:
    - php artisan make:seeder CategoriasSeeder

    BOAS PRÁTICAS:
        - Factory -> singular
        - Seeder -> plural

    Vamos importar o Model no Seeder com: user App\modules\Categoria;

    E em seguida, geramos os 5 registros com o factory encadeando no create:

    public function run()
    {
        Categoria::factory(5)->create();
    }

4. Agora precisamos definir a nossa CategoriaFactory na call do DatabaseSeeder
    Detalhe, se formos executar apenas esta Seeder, não precisa do array na call e pode passar direto na call()
    Ficando: $this->call(CategoriasSeeder::class);

5. Agora basta executar a seed do projeto:
    php artisan db:seed

******************************************************************************
MFSCR

Podemos criar todos esse recursos com um só comando, com:

    php artisan make:model Teste --migration --factory --seed --controller --
    
Ou,

    php artisan make:model Teste -mfscr

******************************************************************************
FACTORY PRODUTOS e STRSLUG

O Laravel dispõem para a gente uma série de classes para serem utilizadas e uma delas é o Str (que serve para gerar uma Url amigável)

Até então só vimos o método create do Eloquent, mas tem outros, como é o caso do pluck
Pluck: extrai uma informação de uma tabela (no nosso caso queremos o id das tabelas Users e Categorias para fazer o relacionamento)

O definition() de nossa factory ficou da seguinte maneira:

    public function definition()
    {   
        $name = $this->faker->unique()->sentence(); // Define o valor de nome antes para colocar em uma variável
        return [
            'nome' => $name, // define nome
            'descricao' => $this->faker->paragraph(), // define a descricao como um parágrafo fake
            'preco' => $this->faker->randomNumber(2), // gera um número aleatório para colocar em preco
            'slug' => Str::slug($name), // gera uma url com a classe Str
            'imagem' => $this->faker>imageUrl(400, 400), // gera a url de uma imagem de dimensão 400x400
            'id_user' => User::pluck('id')->random(), // Extrai randomicamente um dos Ids da tabela users
            'id_categoria' => Categoria::pluck('id')->random(), // Extrai randomicamente um dos Ids da tabela categorias
        ];
    }

Agora iremos definir a nossa Seed:

    public function run()
    {
        Produto::factory(20)->create();
    }

Por últimos chamamos a seed no DatabaseSeeder

******************************************************************************
RELACIONAMENTOS

1. Vamos começar criando dois migrations
    - php artisan make:migration contatos --create=contatos
    - php artisan make:migration regras --create=regras

    Antes nós tinhamos um relacionamento de 1 para muitos entre produtos e usuários (1 user pode ter muitos prosdutos)
    
2. Agora vamos criar um relacionamento de 1:1 entre usuário e contato para que cada usuário tenha apenas 1 :

    public function up()
    {
        Schema::create('contatos', function (Blueprint $table) {
            $table->id();
            $table->string('cpf');
            $table->string('cep');
            $table->string('numero');
            $table->string('whatsapp');
            
            $table->unsignedBigInteger('id_user');
            $table->foreign('id_user')->references('id')->on('users')->onDelete('cascade')->onUpdate('cascade');

            $table->timestamps();
        });
    }

3. Vamos criar um relacionamento de n:n entre a tabela regras e usuários:

    public function up()
    {
        Schema::create('regras', function (Blueprint $table) {
            $table->id();
            $table->string('nome');
            $table->timestamps();
        });

        Schema::create('regra_user', function (Blueprint $table) {
            $table->id();

            $table->unsignedBigInteger('id_user');
            $table->foreign('id_user')->references('id')->on('users');

            $table->unsignedBigInteger('id_regra');
            $table->foreign('id_regra')->references('id')->on('regras');

            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('regras');
        Schema::dropIfExists('regra_user');
    }

    Repare que para criar um relacionamento de n:n devemos criar outra tabela entre as tabelas relacionadas.

4. Agora basta dar um: php artisan migrate

******************************************************************************
VIEWS

Aa Views é a camada do MVC responsável pela vizualização

Ficam dentro da pasta Resource e sua extensão é .blade.php

Blade: sistema de templates do Laravel

É responsabilidade da View renderizar o HTML

QUAL É O FLUXO???

1. Temos uma rota (controller) do tipo Resource em Produtos

    - Então quando acessamos produtos, o Controller ProdutoController responde por essas rotas
    - Route::resource('produtos', ProdutoController::class);

2. Agora vamos mudar esta rota para que ao invés de mostrar os produtos ele retorne uma view, fazemos isso com:

    return view('news');

    Isso mesmo, não precisa botar a extenção, o Laravel já interpreta tudo
    
    Desse modo vamos conseguir renderizar um HTML em nossa aplicação.

    Obs.: Caso dentro da pasta View a gente tivesse uma outra pasta chamada Site bastava passa o caminho com / ou . que seria renderizado.
    return view('site.empresa'); ou return view('site/empresa');

3. E como fazemos para passar um dado para a View?

    Basta passar em um array na rota:

    public function index()
    {
        $nome = 'Johan';
        $idade = 22;

        return view('site.empresa', ['nome' => $nome, 'idade' => $idade]);
    }

4. E para usar esse valor na View???

    Só usar {{}} chaves duplas.

    Ex: <span>Meu nome é {{ $nome }} e minha idade é {{$idade}}.</span>

5. E se nossa variável tivesse conteúdo HTML, como exibiríamos na View?

    Já adianto que com chaves duplas iria mostrar na tela o html literal

    Para renderizar o HTML ao invés de chaves duplas vamos usar chaves e dupla exclamação:

    Passando na rota:           $html = "<h1> Olá, eu sou H1</h1>";
    Renderizando na view:       {!!$html!!}

6. Também tem outra forma de passar as informações para as views sem precisar ser através de Array, para isso usamos o compact():

    return view('site.empresa', compact('nome', 'idade', 'html'));

    basta passar o nome da variável que a função já crias as variáveis na view manualmente

    Atenção, não pode passar atributo no compact de variável que já não exista previamente

******************************************************************************
Section, Yield e extends

Vamos agora trabalhar com nosso sistema de templates

1. Vamos deletar alguns arquivos: welcome.blade, news.blade
2. Renomear o empresa.blade para layout.blade.php
3. Criar em site mais um arquivo chamado home.blade.php

Dentro do layout vamos gerar uma estrutura padrão de HTML e no body vamos usar a nossa primeira diretiva (@yield) para incorporar o nosso conteúdo

    <body>
        @yield('conteudo')
    </body>

Agora para herdar a estrutura de um .blade podemos usar a diretiva @extends, então no home.blade podemos herdar o layout
    
    Logo, dentro do arquivo colocamos apenas: @extends('site.layout') e já vai herdar a estrutura

    Mas ainda no home delimitamos através da @section() e @endsection onde será encontrado o nosso conteúdo

    Ou seja, se no layout foi definido um @yield('conteudo'), lá no home dentro do @session('conteudo') passamos o mesmo nome usado no @yield. E aí todo conteúdo delimitado no @session irá ficar onde foi colocado o @yield no layout.

Desse modo, a home.blade ficou:

    @extends('site.layout')

    @section('conteudo')
    <h1>Essa é nossa Home.</h1>
    @endsection

    Isso herda a estrutura html que foi colocada no layout e coloca o que está delimitado na @section dentro de onde foi apontado no @yield do layout

Podemos por exemplo criar uma sessão para o title e um yield no layout e aí o título ficará dinâmico, isso pode ser feito com o @sectione @endsection
normalmente ou em apenas uma linha passando dois parâmetros para o section:     

    @section('title','home')

    E no lugar do título do layout um @yield('title'), óbvio

****************************************************************************** CHEGANDO AQUI TEMOS UMA VISÃO GERAL DA MECÂNICA DO LARAVEL
Laravel Snippers

Vamos instalar algumas extensões:

    1. Laravel Blade Snippets (deixa os templates mais amigáveis e nos ajuda com alguns triggers: autocompletes)
        - Vai ter uma colocaração diferentes as diretivas

    2. Laravel Snippets (Para as Rotas)
        - Só em digitar um Route-ControllerAction já vai autocomlpetar pra gente com:   Route::get('users/{id}', [UserController::class, 'index'])->name('user.index');
        Já cria a rota, só substituir o valores

******************************************************************************
Comentários e Operador Ternário

Comentários: no blade usamos {{--comentário--}} duplo traço dentro de dupla chaves
    - Estes comentários não são renderizados em nosso código fonte

Operador Ternário: 

    Como exemplo vamos verificar a existência de uma variável e exibir um conteúdo:

        {{ isset($nome) ? $nome : 'Sem nome'}}

    Também podemos definir um valor padrão para uma variável, será mostrado caso a variável não exista. Fazemos isso com: 

        {{$teste ?? 'Padrão'}}

******************************************************************************
CUSTOMIZANDO VIEWS DE ERRO

Criamos dentro da Pasta Views, umas pasta chamada errors, e dentro dela um arquivo com o código do erro. Ex: 404.blade.php

Temos o erro 500 que é de servidor, então se gerarmos propositalmente um erro de sintaxe em uma rota, criar o arquivo com o código do erro e na nossa .env colocar um false p/ APP_DEBUG=false conseguiremos renderizar essa view de erro

******************************************************************************
ESTRUTURAS DE CONTROLE

Basta usar a diretiva @if. Exemplo:

    @if($nome == 'Johan')
        true
    @else
        false
    @endif

    imprime true se for verdadeira

E temos o contrário do If, que é o unless (é tipo a condição negada):

    @unless($nome == 'Johan')
        true
    @else
        false
    @endunless

    imprime true se for falsa

Também temos o bom e velho Switch:

    @switch($idade)
        @case(22)
            Idade está ok
            @break
        @case(21)
            Idade está errada
            @break
        @default            
    @endswitch

Obs.: lembrando que com os snippets só em escrever switch ele já autocompleta, assim como para as outras estruturas

Temos o isset (para verificar se existe):

    @isset($nome)
        Existe
    @endisset

Temos o empty (para verificar se está vazia):

    @empty($nome)
        Vazia
    @endempty

Temos uma diretiva para verificar se existe um usuário autenticado @auth:

    @auth
        Está autenticado
    @endauth

    Imprime se tiver um usuário autenticado

Mas temos o inverso do @auth para retornar o valor caso não haja nenhum usuário autenticado:

    @guest
        Ninguém está autenticado
    @endguest

    Imprime se não tiver nenhum usuário autenticado
